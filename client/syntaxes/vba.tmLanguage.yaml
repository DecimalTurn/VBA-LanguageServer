name: vba
scopeName: source.vba
fileTypes:
  - .bas
  - .cls
  - .frm

patterns:
  - include: "#fileStructure"


# --- Notes ------------------------------------------------------------------------------------
# * TextMate will only evaluate a single line at a time. For syntax spanning multiple lines,
#   a begin/end rule is the only option.
# * TextMate will always fail gracefully. You can misspell a key or name, write an invalid
#   regex pattern, or summon Beetlejuice. It will still run, it just won't work as expected.
#
# --- Match Rules ------------------------------------------------------------------------------
# * Match rules contain a match key.
# * Matches are always consumed but can be passed down to captures key.
# * Patterns, begin, end, beginCaptures, and endCaptures keys will be ignored.
# * Repository key contains more rules but you can only call down the tree or to a top level.

# --- Begin/End Rules --------------------------------------------------------------------------
# * Begin/end rules contain a begin key and (usually) an end key.
# * Rules missing an end key will match to the end of the document (or capture - see tips).
# * Similar to match/captures, you can pair begin/beginCaptures and end/endCaptures.
# * Repository key is ignored and rules within are not accessible from anywhere.
# * Patterns are tested after end. A begin and end that match the same thing immediately exits.
#   Note that this is only relevant to lookarounds as matches will consume the text.
# * An empty end key will not run any includes as it will always immediately exit.

# --- Empty Rules ------------------------------------------------------------------------------
# * Empty rules are used to organise rule flow with a patterns key, and optionally, repository.
# * They will never consume any content as they have no regex.
# * These rules cannot assign scope, so the name key wil be ignored. This may help to organise
# * your grammar, but can make it more difficult to test and debug.

# --- Tips and Tricks --------------------------------------------------------------------------
# * It can be advantageous to match without consuming anything, e.g., multi-level begin/end
#   rules. You can cascade ends with (?=foo) to match anything without consuming. --NOTE--
#   Recursive rules that "ride the kick" with lookarounds must always capture at the top level
#   or the first exit condition will exit all levels of recursion.
#   Similarly, you may wish to end at [':\n] but consuming will cause comments to fail.
# * You can strategically consume content to skip it matching elsewhere, e.g., line continuation
#   on a comment. Begin on ' and end on \n. If you consume the continuation _\s*\n then the
#   comment will continue until the next line that doesn't have the continuation pattern.
# * Begin/End rules run until ended or until they reach the end of their scope of operation.
#   This means passing a capture group from (begin|end)?capture down to a begin/end will _always
#   end at the end of the what was captured!_. This cannot be more than to the end of the line.
# * An empty match key, i.e., begin/end/match will always "match".
#
#   "Put conventional logic aside and enjoy. Well... I say, 'enjoy.'"
#       - Garth Marenghi
# ----------------------------------------------------------------------------------------------


repository:
  fileStructure:
    patterns:
      - include: "#moduleHeader"
      - include: "#labels"
      - include: "#main"

  lineContinuation:
    name: keyword.control.line-continuation.vba
    match: (?<=\s)_\s*\n

  main:
    patterns:
      - include: "#enum"
      - include: "#struct"
      - include: "#methodSignature"
      - include: "#declaration"
      - include: "#block"


  language:
    name: source.language.vba
    patterns:
      - include: "#comments"
      - include: "#vbaBuiltIns"
      - include: "#literals"
      - include: "#operators"
      - include: "#openStatement"
      - include: "#forLoop"
      - include: "#keywords"
      - include: "#functionCall"
      - include: "#subCall"
      - include: "#subCallNoArgs"
      - name: keyword.control.line-separator.vba
        match: ':'

      
  literals:
    patterns:
      - include: "#string"
      - include: "#boolean"
      - include: "#nothing"
      - include: "#number"
      - include: "#hexadecimal"
    repository:
      string:
        name: string.quoted.double.vba
        match: '"("")*([^"\n]*)((?:"")[^"\n]+)?"("")*'
      boolean:
        name: constant.language.boolean.vba
        match: "(?i)(true|false)"
      nothing:
        name: constant.language.null.vba
        match: (?i)\bnothing\b
      number:
        name: constant.numeric.vba
        match: -?\d+\.?\d*[%&@!#]?
      hexadecimal:
        name: constant.numeric.hex.vba
        match: "(?i)&H[0-9a-f]+(&)?"

  operators:
    patterns:
      - include: "#opsNew"
      - include: "#opsArithmetic"
      - include: "#opsComparison"
      - include: "#opsConcatenation"
      - include: "#opsRange"
      - include: "#opsLogical"
      - include: "#opsOther"
    repository:
      opsNew:
        name: keyword.operator.new.vba
        match: (?i)(\bNew\b)
      opsArithmetic:
        name: keyword.operator.arithmetic.vba
        match: (?i)([*&\/\^\+\-]|\^|\bMod\b)
      opsComparison:
        name: keyword.operator.comparison.vba
        match: (?i)([<>=]|\b(is|like)\b)
      opsRange:
        name: keyword.operator.range.vba
        match: (?i)\bto\b
      opsConcatenation:
        name: keyword.operator.concatenation.vba
        match: (?i)[&+]
      opsLogical:
        name: keyword.operator.logical.vba
        match: (?i)\b(and|eqv|imp|not|or|xor)\b
      opsOther:
        name: keyword.operator.other.vba
        match: (?i)\b(addressof|typeof)\b

  keywords:
    patterns:
      - include: "#kw-controlAs"
      - include: "#kw-controlAs"
      - include: "#kw-storageMe"
      - include: "#kw-flow"
      - include: "#kw-array"
      - include: "#kw-directives"
    repository:
      kw-controlAs:
        name: keyword.control.as.vba
        match: (?i)\bas\b

      kw-storageMe:
        name: variable.language.me.vba
        match: (?i)\bme\b

      kw-flow:
        patterns:
          - include: "#inlineIfElse"
          - include: "#inlineIf"
          - include: "#blockIf"
          - include: "#flowLoop"
          - include: "#flowCall"
          - include: "#methodClose"
          - include: "#flowPauseExit"
          - include: "#flowBranch"
          - include: "#flowSwitch"
        repository:
          blockIf:
            name: meta.block-if-else.vba
            begin: (?i)(#?if)\s+(?=[^'\n])  # Look ahead to anything other than a comment.
            end: (?i)#?if                   # Safe to assume this is not an open.
            beginCaptures:
              1:
                name: keyword.control.block-if.open.vba
            endCaptures:
              0:
                name: keyword.control.block-if.close.vba
            patterns:
              - include: "#blockIfOpen"

          blockIfOpen:
            name: meta.block-if.condition.vba
            begin: ""
            end: (?i)(?=if)
            patterns:
              - include: "#lineContinuation"
              - include: "#blockIfThen"
              - include: "#expression"

          blockIfThen:
            name: meta.block-if.then.vba
            begin: (?i)then
            end: (?i)(?=if(?:\s*)['\n])
            beginCaptures:
              0:
                name: keyword.control.block-if.open.vba
            patterns:
              - include: "#lineContinuation"
              - include: "#blockElseIfOpen"
              - include: "#blockEndIf"
              - include: "#blockElse"
              - include: "#main"
          
          blockElseIfOpen:
            name: meta.block-if-else-if.vba
            begin: (?i)(#?else)\s+(?=(if|_))
            end: (?i)(?=if(?:\s*)['\n])
            beginCaptures:
              1:
                name: keyword.control.block-if.open.vba
            patterns:
              - include: "#lineContinuation"
              - include: "#blockElseIf"

          blockElseIf:
            begin: (?i)(if)\s+(?=[^'\n])
            end: (?i)(?=if(?:\s*)['\n])
            beginCaptures:
              1:
                name: keyword.control.block-if.open.vba
            patterns:
              - include: "#blockIfOpen"

          blockElse:
            name: keyword.control.block-if.else.vba
            match: (?i)#?else

          blockEndIf:
            begin: (?i)(#?end)\s+(?=(if|_))
            end: (?i)(?=if(?:\s*)['\n])
            beginCaptures:
              1:
                name: keyword.control.block-if.close.vba
            patterns:
              - include: "#lineContinuation"

          flowLoop:
            name: keyword.control.flow.loop.vba
            match: (?i)\b(do|exit\s+do|while|wend|until|loop|exit\s+for|with)\b

          
          inlineIfElse:
            name: meta.flow.inline-if-else.vba
            match: (?i)\s*((?:else\s+)?if)\s+(.*?)\s+(then)\s+(.*)\s+(else)\s+([^'\n]*)
            captures:
              1:
                name: keyword.control.flow.decision.vba
              2:
                patterns:
                  - include: "#expression"
                  - include: "#functionCall"
              3:
                name: keyword.control.flow.decision.vba
              4:
                patterns:
                  - include: "#inlineIfElse"
                  - include: "#inlineIf"
                  - include: "#valueAssignment"
                  - include: "#language"
                  - include: "#expression"
                  - include: "#functionCall"
              5:
                name: keyword.control.flow.decision.vba
              6:
                patterns:
                  - include: "#valueAssignment"
                  - include: "#language"
          
          inlineIf:
            name: meta.flow.inline-if.vba
            match: (?i)\s*((?:else\s+)?if)\s+(.*?)\s+(then)\s+([^'\n]+)
            captures:
              1:
                name: keyword.control.flow.decision.vba
              2:
                patterns:
                  - include: "#expression"
                  - include: "#functionCall"
              3:
                name: keyword.control.flow.decision.vba
              4:
                patterns:
                  - include: "#inlineIfElse"
                  - include: "#inlineIf"
                  - include: "#valueAssignment"
                  - include: "#language"

          flowCall:
            name: keyword.control.flow.call.vba
            match: "(?i)\\bcall\\b"

          flowPauseExit:
            name: keyword.control.flow.other.vba
            match: "(?i)\\b(doevents|end(?! (sub|property|function))|exit\\s+sub|exit\\s+function|exit\\s+property|stop)\\b"
            
          flowBranch:
            patterns:
              - include: "#onErrorStatement"
              - include: "#onExpressionGoStatement"
              - include: "#goToGoSubReturnStatement"
            repository:
              onErrorStatement:
                name: meta.onErrorStatement.vba
                match: (?i)\b(on\s+error)\s+(?:(resume\s+next)|(goto)\s+([a-z0-9_]+))
                captures:
                  1:
                    name: keyword.control.flow.jump.vba
                  2:
                    name: keyword.control.flow.jump.vba
                  3:
                    name: keyword.control.flow.jump.vba
                  4:
                    patterns:
                      - include: "#literals"
                      - match: .*
                        name: variable.other.constant.label.vba

              onExpressionGoStatement:
                name: meta.onExpressionGoStatement.vba
                begin: (?i)\b(on)\s+(.*?)(go(?:to|sub))
                end: ([\n':])
                beginCaptures:
                  1:
                    name: keyword.control.flow.jump.vba
                  2:
                    patterns: 
                      - include: "#expression"
                  3:
                    name: keyword.control.flow.jump.vba
                patterns:
                  - include: "#separator"
                  - include: "#literals"
                  - match: (?i)([a-z][a-z0-9_]*)
                    name: variable.other.constant.label.vba
              goToGoSubReturnStatement:
                name: meta.goToGoSubReturnStatement.vba
                match: (?i)\b(gosub|return|goto)(?:\s+([a-z][a-z0-9_]*|\d+))?\b
                captures:
                  1:
                    name: keyword.control.jump.vba
                  2:
                    patterns:
                      - include: "#literals"
                      - match: .*
                        name: variable.other.constant.label.vba

          flowSwitch:
            name: meta.flow.switch.vba
            begin: (?i)(select\s+case\b)(.*)
            end: (?i)end\s+select\b
            beginCaptures:
              1:
                name: keyword.control.flow.switch.vba
              2:
                patterns:
                  - include: "#expression"
            endCaptures:
              0:
                name: keyword.control.flow.switch.vba
            patterns:
              - include: "#flowCase"
              - include: "#block"

      kw-array:
        name: keyword.array.vba
        match: "(?i)\\b(redim|erase)(\\s+preserve)?\\b"

      kw-directives:
        patterns:
          - include: "#directiveIf"
          - include: "#directiveConst"
          - include: "#directiveIllegal"
        repository:
          directiveIf:
            name: keyword.directive.vba
            match: "(?i)^(#if|#then|#elseif|#else)\\b"
            
          directiveConst:
            match: "(?i)^\\s*(#const)\\s+([a-z][a-z0-9_]*)(\\s+=.*)"
            captures:
              1:
                name: constant.language.vba
              2:
                name: variable.other.constant.property
              3:
                patterns:
                  - include: "#language"
          
          directiveIllegal:
            name: invalid.illegal.vba
            match: "^#.*"

  openStatement:
    name: meta.open-statement.vba
    begin: (?i)open\b
    end: (?i)(?<!_)(?=\n|:|\s*')
    beginCaptures:
      0:
        name: keyword.control.vba
    patterns:
      - include: "#openStatementPath"
      - include: "#lineContinuation"

  openStatementPath:
    name: meta.openStatementPath.vba
    begin: (?i)[a-z\."]\S*\s+
    end: (?i)(?<!_)(?=\n|:|\s*')
    beginCaptures:
      0:
        patterns:
          - include: "#functionCall"
          - include: "#variable"
          - include: "#literals"
    patterns:
      - include: "#openStatementFor"
      - include: "#lineContinuation"

  openStatementFor:
    name: meta.openStatementFor.vba
    begin: (?i)for(?=[^\S\n])
    end: (?i)(?<!_)(?=\n|:|\s*')
    beginCaptures:
      0:
        name: keyword.control.vba
    patterns:
      - include: "#openStatementMode"
      - include: "#lineContinuation"

  openStatementMode:
    name: meta.openStatementMode.vba
    begin: (?i)(append|binary|input|output|random)(?=[^\S\r\n]|$)
    end: (?i)(?i)(?<!_)(?=\n|:|\s*')
    beginCaptures:
      0:
        name: storage.type.vba
    patterns:
      - include: "#openStatementAccess"
      - include: "#openStatementShared"
      - include: "#openStatementLock"
      - include: "#openStatementAs"
      - include: "#lineContinuation"

  openStatementAccess:
    name: meta.openStatementAccess.vba
    begin: (?i)(access)(?=[^\S\r\n]|$)
    end: (?i)(?i)(?<!_)(?=\n|:|\s*')
    beginCaptures:
      0:
        name: keyword.control.vba
    patterns:
      - include: "#openStatementAccessRead"
      - include: "#openStatementAccessWrite"
      - include: "#lineContinuation"

  openStatementAccessRead:
    name: meta.openStatementAccessRead.vba
    begin: (?i)read(?=[^\S\r\n]|$)
    end: (?i)(?i)(?<!_)(?=\n|:|\s*')
    beginCaptures:
      0:
        name: storage.type.vba
    patterns:
      - include: "#openStatementAccessWrite"
      - include: "#openStatementShared"
      - include: "#openStatementLock"
      - include: "#openStatementAs"
      - include: "#lineContinuation"

  openStatementAccessWrite:
    name: meta.openStatementAccessWrite.vba
    begin: (?i)write(?=[^\S\r\n]|$)
    end: (?i)(?i)(?<!_)(?=\n|:|\s*')
    beginCaptures:
      0:
        name: storage.type.vba
    patterns:
      - include: "#openStatementShared"
      - include: "#openStatementLock"
      - include: "#openStatementAs"
      - include: "#lineContinuation"

  openStatementShared:
    name: meta.openStatementShared.vba
    begin: (?i)shared
    end: (?i)(?i)(?<!_)(?=\n|:|\s*')
    beginCaptures:
      0:
        name: keyword.control.vba
    patterns:
      - include: "#openStatementAs"
      - include: "#lineContinuation"

  openStatementLock:
    name: meta.openStatementLock.vba
    begin: (?i)lock
    end: (?i)(?i)(?<!_)(?=\n|:|\s*')
    beginCaptures:
      0:
        name: keyword.control.vba
    patterns:
      - include: "#openStatementRead"
      - include: "#openStatementWrite"
      - include: "#lineContinuation"

  openStatementRead:
    name: meta.openStatementRead.vba
    begin: (?i)read
    end: (?i)(?i)(?<!_)(?=\n|:|\s*')
    beginCaptures:
      0:
        name: storage.type.vba
    patterns:
      - include: "#openStatementWrite"
      - include: "#openStatementAs"
      - include: "#lineContinuation"

  openStatementWrite:
    name: meta.openStatementWrite.vba
    begin: (?i)write
    end: (?i)(?i)(?<!_)(?=\n|:|\s*')
    beginCaptures:
      0:
        name: storage.type.vba
    patterns:
      - include: "#openStatementAs"
      - include: "#lineContinuation"

  openStatementAs:
    name: meta.openStatementAs.vba
    begin: (?i)as
    end: (?i)(?i)(?<!_)(?=\n|:|\s*')
    beginCaptures:
      0:
        name: keyword.control.vba
    patterns:
      - include: "#openStatementFileNumber"
      - include: "#lineContinuation"

  openStatementFileNumber:
    name: meta.openStatementFileNumber.vba
    begin: (?i)(#)?([.a-z0-9]\w*)
    end: (?i)(?i)(?<!_)(?=\n|:|\s*')
    beginCaptures:
      1:
        name: support.type.primitive.vba
      2:
        patterns:
          - include: "#functionCall"
          - include: "#variable"
          - include: "#literals"
    patterns:
      - include: "#openStatementLen"
      - include: "#lineContinuation"

  openStatementLen:
    name: meta.openStatementLen.vba
    begin: (?i)len
    end: (?i)(?i)(?<!_)(?=\n|:|\s*')
    beginCaptures:
      0:
        name: keyword.control.vba
    patterns:
      - include: "#openStatementLenEquals"
      - include: "#lineContinuation"

  openStatementLenEquals:
    name: meta.openStatementLenEquals.vba
    begin: (?i)\s+=\s+
    end: (?i)(?i)(?<!_)(?=\n|:|\s*')
    beginCaptures:
      0:
        name: keyword.operator.assignment.vba
    patterns:
      - include: "#expression"
      - include: "#lineContinuation"

  forLoop:
    name: meta.flow.for-loop.vba
    begin: (?i)\bfor\s+(?=[^'\n])
        # end: (?i)(next)(\s*['\n]|\s+[a-z][a-z_0-9]*)

    end: (?i)(next)(\s+[a-z]\w*)?
    beginCaptures:
      0:
        name: keyword.control.flow.loop.vba
    endCaptures:
      1:
        name: keyword.control.flow.loop.vba
      2:
        patterns:
          - include: "#variable"
    patterns:
      - include: "#forLoopEach"
      - include: "#forLoopIter"
      - include: "#lineContinuation"


  forLoopEach:
    name: meta.for-each-loop.vba
    begin: (?i)each\s+(?=[^'\n])
    end: (?i)(?=(next)(['\n]|\s+[a-z][a-z_0-9]*|\s+_))
    beginCaptures:
      0:
        name: keyword.control.flow.loop.vba
    patterns:
      - include: "#forLoopEachVar"
      - include: "#lineContinuation"

  forLoopEachVar:
    name: meta.forLoopEachVar.vba
    begin: (?i)[\w]*
    end: (?i)(?=(next)(['\n]|\s+[a-z][a-z_0-9]*|\s+_))
    beginCaptures:
      0:
        patterns:
          - include: "#variable"
    patterns:
      - include: "#lineContinuation"
      - include: "#forLoopEachIn"
      - include: "#variable"

  forLoopEachIn:
    name: meta.forLoopEachIn.vba
    begin: (?i)in\s+
    end: (?i)(?=(next)(['\n]|\s+[a-z][a-z_0-9]*|\s+_))
    beginCaptures:
      0:
        name: keyword.control.flow.loop.vba
    patterns:
      - include: "#lineContinuation"
      - include: "#forLoopEachSet"

  forLoopEachSet:
    name: meta.forLoopEachSet.vba
    begin: (?i)[.\w()]*
    end: (?i)(?=(next)(['\n]|\s+[a-z][a-z_0-9]*|\s+_))
    beginCaptures:
      0:
        patterns:
          - include: "#functionCall"
          - include: "#variable"
    patterns:
      - include: "#block"

  forLoopIter:
    name: meta.for-iterator-loop.vba
    begin: (?i)[a-z][\w]*
    end: (?i)(?=(next)(['\n]|\s+[a-z][a-z_0-9]*|\s+_))
    beginCaptures:
      0:
        patterns:
          - include: "#variable"
    patterns:
      - include: "#lineContinuation"
      - include: "#forLoopIterAssignment"

  forLoopIterAssignment:
    name: meta.forLoopIterAssignment.vba
    begin: =
    end: (?i)(?=(next)(['\n]|\s+[a-z][a-z_0-9]*|\s+_))
    beginCaptures:
      0:
        name: keyword.operator.assignment.vba
    patterns:
      - include: "#lineContinuation"
      - include: "#forLoopIterAssignRangeFrom"

  forLoopIterAssignRangeFrom:
    name: meta.forLoopIterAssignRangeFrom.vba
    begin: (?i)[-.\w()]+
    end: (?i)(?=(next)(['\n]|\s+[a-z][a-z_0-9]*|\s+_))
    beginCaptures:
      0:
        patterns:
          - include: "#functionCall"
          - include: "#variable"
          - include: "#literals"
    patterns:
      - include: "#lineContinuation"
      - include: "#forLoopIterAssignTo"
    
  forLoopIterAssignTo:
    name: meta.forLoopIterAssignTo.vba
    begin: (?i)to
    end: (?i)(?=(next)(['\n]|\s+[a-z][a-z_0-9]*|\s+_))
    beginCaptures:
      0:
        name: keyword.control.flow.loop.vba
    patterns:
      - include: "#lineContinuation"
      - include: "#forLoopIterAssignRangeTo"

  forLoopIterAssignRangeTo:
    name: meta.forLoopIterAssignRangeTo.vba
    begin: (?i)[-.\w()]+
    end: (?i)(?=(next)(['\n]|\s+[a-z][a-z_0-9]*|\s+_))
    beginCaptures:
      0:
        patterns:
          - include: "#functionCall"
          - include: "#variable"
          - include: "#literals"
    patterns:
      - include: "#lineContinuation"
      - include: "#forLoopIterRangeStep"
      - include: "#block"

  forLoopIterRangeStep:
    name: meta.forLoopIterRangeStep.vba
    begin: (?i)step
    end: (?i)(?=(next)(['\n]|\s+[a-z][a-z_0-9]*|\s+_))
    beginCaptures:
      0:
        name: keyword.control.flow.loop.vba
    patterns:
      - include: "#lineContinuation"
      - include: "#forLoopIterRangeStepAmount"

  forLoopIterRangeStepAmount:
    name: meta.forLoopIterRangeStepAmount.vba
    begin: (?i)[-.\w()]+
    end: (?i)(?=(next)(['\n]|\s+[a-z][a-z_0-9]*|\s+_))
    beginCaptures:
      0:
        patterns:
          - include: "#functionCall"
          - include: "#variable"
          - include: "#literals"
    patterns:
      - include: "#block"

  flowCase:
    begin: (?i)case(\s+else)?
    end: (?=[\n:'])
    beginCaptures:
      0:
        name: keyword.control.flow.switch.vba
    patterns:
      - include: "#expressionList"

  labels:
    match: '(?i)^(\s*[a-z][a-z0-9_]*|\d+):'
    captures:
      1:
        name: variable.other.constant.label.vba

  vbaBuiltIns:
    patterns:
      - include: "#vbaEnum"
      - include: "#vbaConstant"
    repository:
      vbaEnum:
        match: (?i)(vba7|win64)
        name: constant.numeric.enum.vba
      vbaConstant:
        match: (?i)(vbNewLine|vbCr|vbLf|vbCrLf)
        name: constant.numeric.enum.vba

  types:
    name: meta.variables.type.vba
    #          As     New?       Type
    match: (?i)(As)\s+(New\s)?\s*([A-Z][a-z0-9_.]*)
    captures:
      1:
        name: keyword.control.as.vba
      2:
        patterns:
          - include: "#operators"
      3:
        patterns:
          - include: "#AsTypePrimative"
          - include: "#AsTypeObject"
          - name: punctuation.accessor.vba
            match: '\.'
  AsTypePrimative:
    name: support.type.primitive.$1.vba
    match: (?i)(boolean|byte|currency|date|decimal|double|integer|long(long|ptr)?|single|string|variant)\b
  AsTypeObject:
    name: support.type.object.$1.vba
    match: (?i)([a-z][a-z0-9._]*)

  argumentsSignature:
    name: meta.arguments.signature.vba
    begin: (?=[^ ():_])
    end: (?=\))
    patterns:
      - include: "#separator"
      - include: "#lineContinuation"
      - include: "#argumentSignatureFromParamArray"
      - include: "#argumentSignatureFromOptional"
      - include: "#argumentSignatureFromBy"
      - include: "#argumentSignatureFromParam"

  argumentSignatureFromParamArray:
    name: meta.argument-signature.paramarray.vba
    begin: (?i)paramarray
    end: (?=[,):'\n])
    beginCaptures:
      0:
        name: storage.type.modifier.vba
    patterns:
      - include: "#argumentSignatureFromParam"
      - include: "#lineContinuation"

  argumentSignatureFromOptional:
    name: meta.argument-signature.optional.vba
    begin: (?i)optional
    end: (?=[,):'\n])
    beginCaptures:
      0:
        name: storage.type.modifier.vba
    patterns:
      - include: "#argumentSignatureFromBy"
      - include: "#argumentSignatureFromParam"
      - include: "#lineContinuation"

  argumentSignatureFromBy:
    name: meta.argument-signature.by.vba
    begin: (?i)(byref|byval)
    end: (?=[,):'\n])
    beginCaptures:
      0:
        name: storage.modifier.$1.vba
    patterns:
      - include: "#argumentSignatureFromParam"
      - include: "#lineContinuation"

  argumentSignatureFromParam:
    name: meta.argument-signature.param.vba
    begin: (?i)[a-z][a-z0-9_]*(\(\))?
    end: (?=[,):'\n])
    beginCaptures:
      0:
        name: variable.parameter.vba
    patterns:
      - include: "#argumentSignatureFromTypeAs"
      - include: "#lineContinuation"

  argumentSignatureFromTypeAs:
    name: meta.argument-signature.as.vba
    begin: (?i)\bas\b
    end: (?=[,):'\n])
    beginCaptures:
      0:
        patterns:
          - include: "#keywords"
    patterns:
      - include: "#argumentSignatureFromTypeName"
      - include: "#lineContinuation"

  argumentSignatureFromTypeName:
    name: meta.argument-signature.type.vba
    begin: (?i)([a-z][a-z0-9._]*)
    end: (?=[,):'\n])
    beginCaptures:
      0:
        patterns:
          - include: "#AsTypePrimative"
          - include: "#AsTypeObject"
          - name: punctuation.accessor.vba
            match: '\.'
    patterns:
      - include: "#valueAssignment"
      - include: "#lineContinuation"

  arguments:
    name: meta.arguments.vba
    begin: (\s+|\(\s*)
    end: (?=[:)'\n])
    patterns:
      - include: "#lineContinuation"
      - include: "#separator"
      - include: "#expression"

  argumentName:
    name: meta.arg-name.vba
    match: (?i)([a-z][a-z0-9_]*)?(:=)
    captures:
      1:
        name: variable.parameter.name.vba
      2:
        name: punctuation.assignment.parameter.vba

  comments:
    patterns:
      - include: "#blockComments"
      - include: "#apostropheComments"
      - include: "#remarkComments"
    repository:
      blockComments:
        # The sub-pattern consumes the \n if preceded by line continuation.
        # Capturing it there prevents the end pattern being matched.
        name: comment.block.vba
        begin: (?i)(\s*'|(?<=^\d*?|:)\s*Rem\b).*\s_\s*
        end: (?=\n)
        patterns:
          - include: "#lineContinuation"
      apostropheComments:
        name: comment.line.apostrophe.vba
        match: (?i)\s*'[^\n]*
      remarkComments:
        name: comment.line.remark.vba
        match: (?i)(?<=^\d*?|:)\s*Rem\b.*

  moduleHeader:
    patterns:
      - include: "#moduleVersion"
      - include: "#moduleAttributeBlock"
      - include: "#moduleAttribute"
      - include: "#moduleOption"
    repository:
      moduleVersion:
        name: entity.other.attribute-name.block.vba
        match: (?i)^VERSION\s+([.\d]+)\s+CLASS
        captures:
          1:
            patterns:
              - include: "#literals"
      moduleAttribute:
        name: meta.attribute.vba
        match: (?i)^\s*(Attribute)\s+(VB_\w+)\s+(=)\s+(.*)$
        captures:
          1: # Attribute
            name: keyword.attribute.vba
          2: # VB_Name
            name: support.variable.property.vba
          3: # =
            name: keyword.operator.assignment.vba
          4: # "Sam"
            patterns:
              - include: "#literals" 
      moduleAttributeBlock:
        name: entity.other.attribute-name.block.vba
        begin: (?i)^BEGIN
        end: (?i)^END
        patterns:
          - include: "#comments"
          - include: "#attributeAssignment"

      moduleOption:
        name: keyword.control.vba
        match: (?i)^\s*Option\s+(Explicit|Base|Private\s+Module)\b

  attributeAssignment:
    name: meta.attribute-assignment.vba
    match: (?i)([a-z.][a-z0-9._]*)(\s*=\s*)(.*)
    captures:
      1:
        name: support.variable.property.vba
      2:
        name: keyword.operator.assignment.vba
      3:
        patterns:
          - include: "#literals"
          - include: "#comments"

  enum:
    name: meta.enum.declaration.vba
    begin: (?i)^\s*((?:(?:Public|Private)\s+)?\s*Enum)\s+([a-z][a-z0-9_]+)(\s+(?:'|Rem).*)?
    beginCaptures:
      1:
        name: storage.type.enum.vba
      2:
        name: entity.name.type.enum.vba
      3:
        patterns:
          - include: "#comments"
    patterns:
      - include: "#enumMember"
      - include: "#language"
    end: (?i)^\s*(End\s+Enum)(\s+'.*)?
    endCaptures:
      1:
        name: storage.type.enum.vba
      2:
        patterns:
          - include: "#comments"
  
  enumMember:
    match: (?i)^\s*([a-z][a-z0-9_]*)(?:\s*(=)\s*([^\n']*))?(\s*(?:'|Rem).*)?
    captures:
      1:
        name: variable.other.enummember.vba
      2:
        name: keyword.operator.assignment.vba
      3:
        patterns:
          - include: "#language"
      4:
        patterns:
          - include: "#comments"

  struct:
    name: meta.struct.declaration.vba
    begin: (?i)^\s*((?:(?:Public|Private)\s+)?Type)\s+([a-z][a-z0-9_]*)?(\s+(?:'|Rem).*)?
    beginCaptures:
      1: # Type declaration
        name: storage.type.struct.vba
      2: # Type name
        name: entity.name.type.struct.vba
      3: # Comments?
        patterns:
          - include: "#comments"
    patterns:
      - include: "#structProperty"
      - include: "#language"

    end: (?i)^\s*(End\s+Type)(\s+'.*)?
    endCaptures:
      1:
        name: storage.type.struct.vba
      2:
        patterns:
          - include: "#comments"

  structProperty:
    match: (?i)^\s*([a-z][a-z0-9_]*)(\(.*\))?(\s+As\s+[a-z][a-z0-9_]*)?(\s+(?:'|Rem).*)?
    captures:
      1: # Property
        name: variable.other.readwrite.vba
      2: # Array bounds?
        patterns:
          - include: "#language"
      3: # As Type?
        patterns:
          - include: "#types"
      4: # Comments?
        patterns:
          - include: "#comments"

  methodSignature:
    name: source.method.signature.vba
    begin: (?i)^\s*((?:Public|Private)?\b\s*(?:(?:Sub|Function)|Property\s+(?:Let|Get|Set)))\s+([a-z][a-z0-9_]*)\s*(\()
    end: (?i)(?<=\))(\s+as\s+[a-z][a-z0-9_]*)?
    beginCaptures:
      1:
        name: storage.type.method.vba
      2: # name
        name: entity.name.function.vba
    endCaptures:
      1: # return type
        patterns:
          - include: "#types"
    patterns:
      - include: "#argumentsSignature"
      - include: "#lineContinuation"

  methodAttribute:
    name: source.method.attribute.vba
    match: (?i)^\s*(Attribute)\s+([a-z][a-z0-9_]*)(\.VB_(?:Description|UserMemId))\s+(=)\s+(.*)
    captures:
      1:
        name: keyword.attribute.vba
      2:
        name: entity.name.function.vba
      3:
        name: support.variable.property.vba
      4:
        name: keyword.operator.assignment.vba
      5:
        patterns:
          - include: "#literals"

  methodClose:
    name: storage.type.method.close.vba
    match: (?i)End\s+(Sub|Function|Property)(?=$|\s)

  expressionList:
    begin: ""
    end: (?=\n|\sThen|\)|'|:)
    patterns:
      - include: "#separator"
      - include: "#expression"

  expression:
    # Begins and ends without consuming anything.
    name: meta.expression.vba
    begin: (?i)(?!=\n|\sThen|\)|'|,|:|\s)
    end: (?i)(?=\n|\sThen|\)|'|,|:)
    patterns:
      - include: "#literals"
      - include: "#argumentName"
      - include: "#operators"
      - include: "#functionCall"
      - include: "#variable"
      - include: "#lineContinuation"

  block:
    patterns:
      - include: "#declaration"
      - include: "#valueAssignment"
      - include: "#methodAttribute"
      - include: "#methodClose"
      - include: "#language"

  separator:
    name: punctuation.separator.vba
    match: ','

  declaration:
    patterns:
      - include: "#variableDeclarationVisbility"
      - include: "#variableDeclarationDim"
      - include: "#variableDeclarationConst"
      - include: "#methodDeclarationDeclare"
    repository:
      variableDeclarationVisbility:
        name: meta.declare.$1.vba
        begin: (?i)(global|public|private)
        end: (?=[':\n])
        beginCaptures:
          0:
            name: storage.modifier.visibility.vba
        patterns:
          - include: "#separator"
          - include: "#lineContinuation"
          - include: "#variableDeclarationConst"
          - include: "#methodDeclarationDeclare"
          - include: "#variableDeclarationVarName"

      variableDeclarationDim:
        name: meta.declare.variable.vba
        begin: (?i)dim(?=\s)
        end: (?=[':\n])
        beginCaptures:
          0:
            name: storage.type.vba
        patterns:
          - include: "#separator"
          - include: "#lineContinuation"
          - include: "#variableDeclarationVarName"

      variableDeclarationConst:
        name: meta.declare.constant.vba
        begin: (?i)const(?=\s)
        end: (?=[':\n])
        beginCaptures:
          0:
            name: storage.type.vba
        patterns:
          - include: "#separator"
          - include: "#lineContinuation"
          - include: "#variableDeclarationConstName"

      variableDeclarationVarName:
        begin: (?i)[a-z][a-z0-9_]*
        end: (?=[':\n,])
        beginCaptures:
          0:
            patterns:
              - include: "#variable"
        patterns:
          - include: "#lineContinuation"
          - include: "#variableDeclarationTypeAs"
          - include: "#variableDeclarationArrayBounds"

      variableDeclarationArrayBounds:
        name: meta.declare.array-bounds.vba
        begin: \(
        end: \)
        patterns:
          - include: "#separator"
          - include: "#expression"

      variableDeclarationConstName:
        begin: (?i)[a-z][a-z0-9_]*
        end: (?=[':\n,])
        beginCaptures:
          0:
            patterns:
              - include: "#variable"
        patterns:
          - include: "#lineContinuation"
          - include: "#variableDeclarationTypeAs"
          - include: "#valueAssignment"

      variableDeclarationTypeAs:
        begin: (?i)\bas\b
        end: (?=[,):'\n])
        beginCaptures:
          0:
            patterns:
              - include: "#keywords"
        patterns:
          - include: "#lineContinuation"
          - include: "#variableDeclarationTypeNew"
          - include: "#argumentSignatureFromTypeName"

      variableDeclarationTypeNew:
        begin: (?i)\bnew\b
        end: (?=[,):'\n])
        beginCaptures:
          0:
            patterns:
              - include: "#operators"
        patterns:
          - include: "#lineContinuation"
          - include: "#argumentSignatureFromTypeName"

      methodDeclarationDeclare:
        name: meta.declare.function.vba
        begin: (?i)declare
        end: (?=[':\n])
        beginCaptures:
          0:
            name: storage.type.vba
        patterns:
          - include: "#lineContinuation"
          - include: "#methodDeclarationPtrsafe"
          - include: "#methodDeclarationMethod"
          - include: "#argumentSignatureFromTypeAs"

      methodDeclarationPtrsafe:
        begin: (?i)ptrsafe
        end: (?=[)':\n])
        beginCaptures:
          0:
            name: storage.modifier.ptrsafe.vba
        patterns:
          - include: "#lineContinuation"
          - include: "#methodDeclarationMethod"

      methodDeclarationMethod:
        begin: (?i)sub|function
        end: (?=[)':\n])
        beginCaptures:
          0:
            name: storage.type.$0.vba
        patterns:
          - include: "#lineContinuation"
          - include: "#methodDeclarationIdentifier"

      methodDeclarationIdentifier:
        begin: (?i)[a-z][a-z0-9_]*
        end: (?=[)':\n])
        beginCaptures:
          0:
            name: entity.name.function.vba
        patterns:
          - include: "#lineContinuation"
          - include: "#methodDeclarationLib"

      methodDeclarationLib:
        begin: (?i)lib
        end: (?=[)':\n])
        beginCaptures:
          0:
            name: storage.type.dll.vba
        patterns:
          - include: "#lineContinuation"
          - include: "#methodDeclarationLibIdentifier"

      methodDeclarationLibIdentifier:
        begin: (?i)"[a-z][a-z0-9._]*"(\s+\()?
        end: (?=[)':\n])
        beginCaptures:
          0:
            patterns:
              - include: "#literals"
        patterns:
          - include: "#separator"
          - include: "#lineContinuation"
          - include: "#methodDeclarationAlias"
          - include: "#argumentsSignature"

      methodDeclarationAlias:
        begin: (?i)alias
        end: (?=[)':\n])
        beginCaptures:
          0:
            name: storage.type.dll.vba
        patterns:
          - include: "#lineContinuation"
          - include: "#methodDeclarationAliasIdentifier"

      methodDeclarationAliasIdentifier:
        begin: (?i)"[a-z][a-z0-9._]*"
        end: (?=[)':\n])
        beginCaptures:
          0:
            patterns:
              - include: "#literals"
        patterns:
          - include: "#separator"
          - include: "#lineContinuation"
          - include: "#argumentsSignature"

  valueAssignment:
    name: meta.variable-assignment.vba
    begin: (?i)(?:(Let|Set)\s+)?((?:[a-z][a-z0-9_]*)?(?:\.(?:(?:[a-z][a-z0-9_]*)?\.)*)?(?:[a-z][a-z0-9_]*)?)(\s*=\s*)
    end: (?=[',:)\n])
    beginCaptures:
      1: # Let|Set
        name: keyword.control.vba
      2: # Variable property chain name
        patterns:
          - include: "#variable"
      3: # =
        name: keyword.operator.assignment.vba
    patterns:
      - include: "#expression"
      - include: "#functionCall"
      - include: "#variable"
      - include: "#language"
      - include: "#lineContinuation"

  accessorPunctuation:
    name: punctuation.accessor.vba
    match: (?i)\.

  propertyChain:
    match: (?i)(\.)([a-z][a-z0-9_]*)*
    captures:
      1:
        patterns:
          - include: "#accessorPunctuation"
      2:
        name: variable.other.property

  variable:
    name: meta.variable-or-property.vba
    match: (?i)(?:(?:(\bMe\b|\.)|([a-z][a-z0-9_]*)))((?:\.(?:[a-z][a-z0-9_]*))+)?
    captures:
      1:
        patterns:
          - include: "#keywords"
          - include: "#accessorPunctuation"
      2:
        patterns:
          - name: variable.other.constant
            match: ([A-Z][A-Z0-9_]*)\b
          - name: variable.other.readwrite.vba
            match: (?i)([a-z][a-z0-9_]*)
      3:
        patterns:
          - include: "#propertyChain"

  functionCall:
    name: meta.function.call.vba
    begin: (?i)(?:([a-z][a-z0-9_]*)(?=\.))?(\.(?:(?:[a-z][a-z0-9_]*)?\.)*)?([a-z][a-z0-9_]*)([&%#!@$^])?(?=\()
    end: (\)|(?='))
    beginCaptures:
      1:
        patterns:
          - include: "#keywords"
          - include: "#variable"
      2:
        patterns:
          - include: "#propertyChain"
      3:
        name: entity.name.function.call.vba
      4:
        name: support.type.primitive.vba
    patterns:
      # These calls need to be back to a top level group because
      # textMate does not seem to support a repository in a begin/end
      - include: "#arguments"

  subCall:
    name: meta.sub-call.vba
    begin: (?i)(?:([a-z][a-z0-9_]*)(?=\.))?(\.(?:(?:[a-z][a-z0-9_]*)?\.)*)?([a-z][a-z0-9_]*)\s*(?=\s[^,'\n])
    end: (?=[:'\n])
    beginCaptures:
      1:
        patterns:
          - include: "#variable"
      2:
        patterns:
          - include: "#propertyChain"
      3:
        name: entity.name.function.call.vba
    patterns:
      - include: "#arguments"

  subCallNoArgs:
    name: meta.sub-call.vba
    match: (?i)(?:([a-z][a-z0-9_]*)(?=\.))?(\.(?:(?:[a-z][a-z0-9_]*)?\.)*)?([a-z][a-z0-9_]*)
    captures:
      1:
        patterns:
          - include: "#keywords"
          - include: "#variable"
      2:
        patterns:
          - include: "#propertyChain"
      3:
        name: entity.name.function.call.vba
